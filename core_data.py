# -*- coding: utf-8 -*-
"""Core_data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xqJbC8xzTfLYIOTMVezK4ONwLril3xqR
"""

import pandas as pd
import requests
import json
import urllib.parse
from datetime import datetime, date 
import pytz
from datetime import timedelta
from sodapy import Socrata
import geopy.distance


# https://data.lacity.org/resource/s49e-q6j2.json


def get_data(address, radius, time, space_type):
    client = Socrata("data.lacity.org", None)

    # First 2000 results, returned as JSON from API / converted to Python list of
    # dictionaries by sodapy.
    # results = client.get("s49e-q6j2", limit=34000)
    #
    # # Convert to pandas DataFrame
    # results_df = pd.DataFrame.from_records(results)
    # results_df
    #
    # firebase_url = "https://athena-cfcd2-default-rtdb.firebaseio.com/.json"
    # requests.put(firebase_url, results_df.to_json(orient='records'))

    # https://data.lacity.org/resource/e7h6-4a3e.csv

    # First 2000 results, returned as JSON from API / converted to Python list of
    # dictionaries by sodapy.
    realTime = client.get("e7h6-4a3e", limit=10000)

    # Convert to pandas DataFrame
    realTime_df = pd.DataFrame.from_records(realTime)
    realTime_df

    data = realTime_df
    data['final']= ""
    for i in range(len(data)):
      data['eventtime'][i] = data['eventtime'][i].replace("T", " ")
      data['eventtime'][i] = data['eventtime'][i].replace(".000", "")
      data['eventtime'][i] = datetime.strptime(data['eventtime'][i][:-1], '%Y-%m-%d %H:%M:%S')
      final_time = data['eventtime'][i] - timedelta(minutes=10)
      final_time_str = datetime.strftime(final_time, '%Y-%m-%d %H:%M:%S')
      data['final'][i] = datetime.strptime(final_time_str, '%Y-%m-%d %H:%M:%S')
    data

    data_5min = data
    realTime = data_5min.loc[data_5min['eventtime'] > data_5min['final'][0]]
    realTime = realTime.loc[realTime['occupancystate']=="VACANT"]
    realTime

    fixed = pd.read_csv("LADOT_spot_location_revision.csv")
    fixed

    big_table = pd.merge(realTime,fixed,left_on='spaceid',right_on='SpaceID')
    big_table

    # address = '700 W 9th St, Los Angeles, CA'
    url = 'https://maps.googleapis.com/maps/api/geocode/json?address=' + urllib.parse.quote(address) +'&key=AIzaSyBOFmWMr01bVUbxkXQTobmqy2mhI4kvDeA'

    response = requests.get(url)
    # response = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=AIzaSyBOFmWMr01bVUbxkXQTobmqy2mhI4kvDeA')

    resp_json_payload = response.json()
    input_lat = resp_json_payload['results'][0]['geometry']['location']['lat']
    input_long = resp_json_payload['results'][0]['geometry']['location']['lng']
    # resp_json_payload
    print((input_lat, input_long))

    from numpy import False_

    big_table['within'] = ""
    coords_1 = (input_lat, input_long)
    for i in range(len(big_table)):
      coords_2 = (big_table['Lan'][i], big_table['Long'][i])
      dis = geopy.distance.geodesic(coords_1, coords_2).mi
      if (dis <= radius):
        big_table['within'][i] = True
      else:
        big_table['within'][i] = False
    big_table
    # print(geopy.distance.vincenty(coords_1, coords_2).mi)

    aa=big_table.loc[big_table.within]
    aa=aa.loc[aa['MeterType'] == space_type]
    return aa, input_lat, input_long